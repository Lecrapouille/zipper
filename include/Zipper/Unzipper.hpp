//-----------------------------------------------------------------------------
// Copyright (c) 2022 Quentin Quadrat <lecrapouille@gmail.com>
// https://github.com/Lecrapouille/zipper distributed under MIT License.
// Based on https://github.com/sebastiandev/zipper/tree/v2.x.y distributed under
// MIT License. Copyright (c) 2015 -- 2022 Sebastian <devsebas@gmail.com>
//-----------------------------------------------------------------------------

#ifndef ZIPPER_UNZIPPER_HPP
#define ZIPPER_UNZIPPER_HPP

#include <cstdint>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <string>
#include <system_error>
#include <vector>

// *****************************************************************************
// Generated by CMake. Needed for exporting symbols for making the libzipper.dll
// on Windows.
// *****************************************************************************
#if defined(ZIPPER_EXPORT_DEFINED)
#    include "zipper_export.h"
#else
#    define ZIPPER_EXPORT
#endif

namespace zipper {

class ZipEntry;

// *****************************************************************************
//! \brief Zip archive extractor/decompressor.
// *****************************************************************************
class ZIPPER_EXPORT Unzipper
{
public:

    // -------------------------------------------------------------------------
    //! \brief Overwrite mode for extraction operations.
    // -------------------------------------------------------------------------
    enum class OverwriteMode
    {
        DoNotOverwrite, //!< Do not overwrite existing files
        Overwrite       //!< Overwrite existing files
    };

    // -------------------------------------------------------------------------
    //! \brief Structure containing progress information during extraction.
    // -------------------------------------------------------------------------
    struct Progress
    {
        //! \brief Status of the extraction
        enum class Status
        {
            OK,        //!< Extraction completed successfully
            KO,        //!< Extraction failed
            InProgress //!< Extraction in progress
        };

        Status status = Status::InProgress; //!< Current status
        std::string current_file;   //!< Name of the file being extracted
        uint64_t bytes_read = 0;    //!< Number of bytes read so far
        uint64_t total_bytes = 0;   //!< Total number of bytes to extract
        size_t files_extracted = 0; //!< Number of files extracted so far
        size_t total_files = 0;     //!< Total number of files to extract
    };

    // -------------------------------------------------------------------------
    //! \brief Callback type for progress reporting
    //! \param[in] progress Current progress information
    // -------------------------------------------------------------------------
    using ProgressCallback = std::function<void(const Progress&)>;

    // -------------------------------------------------------------------------
    //! \brief Default constructor. Creates an uninitialized Unzipper.
    // -------------------------------------------------------------------------
    Unzipper();

    // -------------------------------------------------------------------------
    //! \brief Regular zip decompressor (from zip archive file).
    //!
    //! \param[in] p_zip_name Path of the zip file to extract.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Unzipper(std::string const& p_zip_name,
             std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip decompressor (from std::iostream).
    //!
    //! \param[in,out] p_buffer Stream containing zipped entries to extract.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Unzipper(std::istream& p_buffer,
             std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip decompressor (from std::vector).
    //!
    //! \param[in] p_buffer Vector containing zipped entries to extract.
    //! The vector content is copied internally.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Unzipper(const std::vector<unsigned char>& p_buffer,
             std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Calls release() and close() methods.
    // -------------------------------------------------------------------------
    ~Unzipper();

    // -------------------------------------------------------------------------
    //! \brief Regular zip decompressor (from zip archive file).
    //!
    //! \param[in] p_zip_name Path of the zip file to extract.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    bool open(std::string const& p_zip_name,
              std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip decompressor (from std::iostream).
    //!
    //! \param[in,out] p_buffer Stream containing zipped entries to extract.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    bool open(std::istream& p_buffer,
              std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip decompressor (from std::vector).
    //!
    //! \param[in] p_buffer Vector containing zipped entries to extract.
    //! The vector content is copied internally.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    bool open(const std::vector<unsigned char>& p_buffer,
              std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Returns all entries contained in the zip archive.
    //! \note If no entries are found, the vector is empty but this may comes
    //! from an internal error. Call error() to get to distinguish between
    //! an empty vector and an internal error.
    //! \return Vector of ZipEntry objects.
    // -------------------------------------------------------------------------
    std::vector<ZipEntry> entries();

    // -------------------------------------------------------------------------
    //! \brief Returns the total uncompressed size of all entries in the zip
    //! archive.
    //! \note Call this method before extractAll() to check if the total
    //! uncompressed size is too large. Prevent zip bomb attacks.
    //! \return Total uncompressed size in bytes.
    // -------------------------------------------------------------------------
    size_t sizeOnDisk();

    // -------------------------------------------------------------------------
    //! \brief Set the progress callback.
    //! \param[in] callback Function to call with progress updates.
    //! \return true if the callback was set, false otherwise.
    // -------------------------------------------------------------------------
    bool setProgressCallback(ProgressCallback callback);

    // -------------------------------------------------------------------------
    //! \brief Extract the whole zip archive using alternative destination names
    //! for existing files on the disk.
    //!
    //! \param[in] p_folder_destination Full path where files will be extracted
    //! (if empty, extracts to same folder as the zip file).
    //! \param[in] p_alternative_names Dictionary of alternative names for
    //! existing files (key: zip entry name, value: desired path name on disk).
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool
    extractAll(std::string const& p_folder_destination,
               const std::map<std::string, std::string>& p_alternative_names,
               OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract the whole archive to the desired disk destination.
    //!
    //! \param[in] p_folder_destination Full path where files will be extracted
    //! (if empty, extracts to same folder as the zip file).
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractAll(std::string const& p_folder_destination,
                    OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract the whole archive to the same folder as the zip file.
    //!
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractAll(OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract entries matching a glob pattern.
    //! \note Glob pattern is a the regular expression syntax used by the Unix
    //! shell.
    //!
    //! \param[in] p_glob Glob pattern to select entries.
    //! \param[in] p_folder_destination Full path where files will be extracted
    //! (if empty, extracts to same folder as the zip file).
    //! \param[in] p_alternative_names Dictionary of alternative names for
    //! existing files (key: zip entry name, value: desired path name on disk).
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool
    extractGlob(std::string const& p_glob,
                std::string const& p_destination,
                const std::map<std::string, std::string>& p_alternative_names,
                OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract entries matching a glob pattern.
    //! \note Glob pattern is a the regular expression syntax used by the Unix
    //! shell.
    //!
    //! \param[in] p_glob Glob pattern to select entries.
    //! \param[in] p_folder_destination Full path where files will be extracted
    //! (if empty, extracts to same folder as the zip file).
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractGlob(std::string const& p_glob,
                     std::string const& p_folder_destination,
                     OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract entries matching a glob pattern.
    //! \note Glob pattern is a the regular expression syntax used by the Unix
    //! shell.
    //!
    //! \param[in] p_glob Glob pattern to select entries.
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractGlob(std::string const& p_glob,
                     OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from the archive.
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[in] p_entry_destination Full path where the file will be
    //! extracted.
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure.
    //! Call error() for more info.
    // -------------------------------------------------------------------------
    bool extract(std::string const& p_entry_name,
                 std::string const& p_entry_destination,
                 OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry to the same folder as the zip file.
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[in] p_overwrite Overwrite mode for extraction operations.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extract(std::string const& p_entry_name,
                 OverwriteMode p_overwrite = OverwriteMode::DoNotOverwrite);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from zip to memory (stream).
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[out] p_output_stream Stream that will receive the extracted entry
    //! data.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extract(std::string const& p_entry_name,
                 std::ostream& p_output_stream);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from zip to memory (vector).
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[out] p_output_buffer Vector that will receive the extracted entry
    //! data.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extract(std::string const& p_entry_name,
                 std::vector<unsigned char>& p_output_buffer);

    // -------------------------------------------------------------------------
    //! \brief Closes the archive. Called by the destructor.
    // -------------------------------------------------------------------------
    void close();

    // -------------------------------------------------------------------------
    //! \brief Get the error information when a method returned false.
    //! \return Reference to the error code.
    // -------------------------------------------------------------------------
    inline std::error_code const& error() const
    {
        return m_error_code;
    }

    // -------------------------------------------------------------------------
    //! \brief Check if the unzipper is currently open and ready for extracting
    //! files.
    //! \return True if the unzipper is open, false otherwise.
    // -------------------------------------------------------------------------
    inline bool isOpened() const
    {
        return m_open;
    }

private:

    // -------------------------------------------------------------------------
    //! \brief Check if the unzipper is valid.
    //! \return true if the unzipper is valid, false otherwise.
    // -------------------------------------------------------------------------
    bool checkValid();

private:

    struct Impl;

    //! \brief Whether the archive is open.
    bool m_open = false;
    //! \brief Error code.
    std::error_code m_error_code;
    //! \brief Implementation.
    std::unique_ptr<Impl> m_impl;
};

// *************************************************************************
//! \brief Class representing an entry in a zip archive.
// *************************************************************************
class ZipEntry
{
public:

    //! \brief Default constructor.
    ZipEntry() = default;

    //! \brief Constructor with entry details.
    //!
    //! \param[in] p_name Name of the entry in the zip archive.
    //! \param[in] p_compressed_size Size of the compressed data in bytes.
    //! \param[in] p_uncompressed_size Original size of the data in bytes.
    //! \param[in] p_year Year component of the timestamp.
    //! \param[in] p_month Month component of the timestamp (1-12).
    //! \param[in] p_day Day component of the timestamp (1-31).
    //! \param[in] p_hour Hour component of the timestamp (0-23).
    //! \param[in] p_minute Minute component of the timestamp (0-59).
    //! \param[in] p_second Second component of the timestamp (0-59).
    //! \param[in] p_dos_date DOS-format date.
    ZipEntry(std::string const& p_name,
             uint64_t p_compressed_size,
             uint64_t p_uncompressed_size,
             uint32_t p_year,
             uint32_t p_month,
             uint32_t p_day,
             uint32_t p_hour,
             uint32_t p_minute,
             uint32_t p_second,
             uint32_t p_dos_date)
        : name(p_name),
          compressed_size(p_compressed_size),
          uncompressed_size(p_uncompressed_size),
          dos_date(p_dos_date)
    {
        // timestamp YYYY-MM-DD HH:MM:SS
        std::stringstream str;
        str << p_year << "-" << p_month << "-" << p_day << " " << p_hour << ":"
            << p_minute << ":" << p_second;
        timestamp = str.str();

        unix_date.tm_year = p_year;
        unix_date.tm_mon = p_month;
        unix_date.tm_mday = p_day;
        unix_date.tm_hour = p_hour;
        unix_date.tm_min = p_minute;
        unix_date.tm_sec = p_second;
    }

    //! \brief Copy constructor.
    ZipEntry(ZipEntry const& p_other) = default;

    //! \brief Copy assignment operator.
    ZipEntry& operator=(ZipEntry const& p_other) = default;

    //! \brief Move assignment operator.
    ZipEntry& operator=(ZipEntry&& p_other) = default;

public:

    //! \brief Structure representing a date and time.
    struct tm_s
    {
        uint32_t tm_sec;  //!< Seconds (0-59)
        uint32_t tm_min;  //!< Minutes (0-59)
        uint32_t tm_hour; //!< Hours (0-23)
        uint32_t tm_mday; //!< Day of month (1-31)
        uint32_t tm_mon;  //!< Month (1-12)
        uint32_t tm_year; //!< Year (full year, e.g. 2022)
    };

    std::string name;      //!< Name of the entry in the zip archive
    std::string timestamp; //!< Formatted timestamp string (YYYY-MM-DD HH:MM:SS)
    uint64_t compressed_size;   //!< Size of the compressed data in bytes
    uint64_t uncompressed_size; //!< Original size of the data in bytes
    uint32_t dos_date;          //!< DOS-format date
    tm_s unix_date;             //!< UNIX-format date and time
};

} // namespace zipper

#endif // ZIPPER_UNZIPPER_HPP
