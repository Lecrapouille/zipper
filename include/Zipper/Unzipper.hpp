//-----------------------------------------------------------------------------
// Copyright (c) 2022 Quentin Quadrat <lecrapouille@gmail.com>
// https://github.com/Lecrapouille/zipper distributed under MIT License.
// Based on https://github.com/sebastiandev/zipper/tree/v2.x.y distributed under
// MIT License. Copyright (c) 2015 -- 2022 Sebastian <devsebas@gmail.com>
//-----------------------------------------------------------------------------

#ifndef ZIPPER_UNZIPPER_HPP
#define ZIPPER_UNZIPPER_HPP

#include <cstdint>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <string>
#include <system_error>
#include <vector>

// *****************************************************************************
// Generated by CMake. Needed for exporting symbols for making the libzipper.dll
// on Windows.
// *****************************************************************************
#if defined(ZIPPER_EXPORT_DEFINED)
#    include "zipper_export.h"
#else
#    define ZIPPER_EXPORT
#endif

namespace zipper {

class ZipEntry;

// *****************************************************************************
//! \brief Zip archive extractor/decompressor.
// *****************************************************************************
class ZIPPER_EXPORT Unzipper
{
public:

    // -------------------------------------------------------------------------
    //! \brief Regular zip decompressor (from zip archive file).
    //!
    //! \param[in] p_zip_name Path of the zip file to extract.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Unzipper(std::string const& p_zip_name,
             std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip decompressor (from std::iostream).
    //!
    //! \param[in,out] p_buffer Stream containing zipped entries to extract.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Unzipper(std::istream& p_buffer,
             std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip decompressor (from std::vector).
    //!
    //! \param[in] p_buffer Vector containing zipped entries to extract.
    //! The vector content is copied internally.
    //! \param[in] p_password Optional password used during compression (empty
    //! if no password).
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Unzipper(const std::vector<unsigned char>& p_buffer,
             std::string const& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Calls release() and close() methods.
    // -------------------------------------------------------------------------
    ~Unzipper();

    // -------------------------------------------------------------------------
    //! \brief Returns all entries contained in the zip archive.
    //! \return Vector of ZipEntry objects.
    // -------------------------------------------------------------------------
    std::vector<ZipEntry> entries();

    // -------------------------------------------------------------------------
    //! \brief Extract the whole zip archive using alternative destination names
    //! for existing files on the disk.
    //!
    //! \param[in] p_destination Full path where files will be extracted (if
    //! empty, extracts to same folder as the zip file).
    //! \param[in] p_alternative_names Dictionary of alternative names for
    //! existing files (key: zip entry name, value: desired path name on disk).
    //! \param[in] p_replace If false (default), throws an exception when a file
    //! already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    inline bool
    extractAll(const char* p_destination,
               const std::map<std::string, std::string>& p_alternative_names,
               bool const p_replace = false)
    {
        return extractAll(
            std::string(p_destination), p_alternative_names, p_replace);
    }

    // -------------------------------------------------------------------------
    //! \brief Extract the whole zip archive using alternative destination names
    //! for existing files on the disk.
    //!
    //! \param[in] p_destination Full path where files will be extracted (if
    //! empty, extracts to same folder as the zip file).
    //! \param[in] p_alternative_names Dictionary of alternative names for
    //! existing files (key: zip entry name, value: desired path name on disk).
    //! \param[in] p_replace If false (default), throws an exception when a file
    //! already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool
    extractAll(std::string const& p_destination,
               const std::map<std::string, std::string>& p_alternative_names,
               bool const p_replace = false);

    // -------------------------------------------------------------------------
    //! \brief Extract the whole archive to the desired disk destination.
    //!
    //! \param[in] p_folder_destination Full path where files will be extracted
    //! (if empty, extracts to same folder as the zip file).
    //! \param[in] p_replace If false (default), throws an exception when a file
    //! already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractAll(std::string const& p_folder_destination,
                    bool const p_replace = false);

    // -------------------------------------------------------------------------
    //! \brief Extract the whole archive to the desired disk destination.
    //!
    //! \param[in] p_folder_destination Full path where files will be extracted
    //! (if empty, extracts to same folder as the zip file).
    //! \param[in] p_replace If false (default), throws an exception when a file
    //! already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    inline bool extractAll(const char* p_folder_destination,
                           bool const p_replace = false)
    {
        return extractAll(std::string(p_folder_destination), p_replace);
    }

    // -------------------------------------------------------------------------
    //! \brief Extract the whole archive to the same folder as the zip file.
    //!
    //! \param[in] p_replace If false (default), throws an exception when a file
    //! already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractAll(bool const p_replace = false);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from the archive.
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[in] p_entry_destination Full path where the file will be
    //! extracted.
    //! \param[in] p_replace If false (default), throws an exception
    //! when the file already exists.
    //! \return true on success, false on failure.
    //! Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractEntry(std::string const& p_entry_name,
                      std::string const& p_entry_destination,
                      bool const p_replace = false);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from the archive.
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[in] p_entry_destination Full path where the file will be
    //! extracted.
    //! \param[in] p_replace If false (default), throws an exception
    //! when the file already exists.
    //! \return true on success, false on failure.
    //! Call error() for more info.
    // -------------------------------------------------------------------------
    inline bool extractEntry(const char* p_entry_name,
                             const char* p_entry_destination,
                             bool const p_replace = false)
    {
        return extractEntry(std::string(p_entry_name),
                            std::string(p_entry_destination),
                            p_replace);
    }

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry to the same folder as the zip file.
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[in] p_replace If false (default), throws an exception when the
    //! file already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractEntry(std::string const& p_entry_name,
                      bool const p_replace = false);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry to the same folder as the zip file.
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[in] p_replace If false (default), throws an exception when the
    //! file already exists.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    inline bool extractEntry(const char* p_entry_name,
                             bool const p_replace = false)
    {
        return extractEntry(std::string(p_entry_name), p_replace);
    }

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from zip to memory (stream).
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[out] p_output_stream Stream that will receive the extracted entry
    //! data.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractEntryToStream(std::string const& p_entry_name,
                              std::ostream& p_output_stream);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from zip to memory (stream).
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[out] p_output_stream Stream that will receive the extracted entry
    //! data.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    inline bool extractEntryToStream(const char* p_entry_name,
                                     std::ostream& p_output_stream)
    {
        return extractEntryToStream(std::string(p_entry_name), p_output_stream);
    }

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from zip to memory (vector).
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[out] p_output_buffer Vector that will receive the extracted entry
    //! data.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    bool extractEntryToMemory(std::string const& p_entry_name,
                              std::vector<unsigned char>& p_output_buffer);

    // -------------------------------------------------------------------------
    //! \brief Extract a single entry from zip to memory (vector).
    //!
    //! \param[in] p_entry_name Entry path inside the zip archive.
    //! \param[out] p_output_buffer Vector that will receive the extracted entry
    //! data.
    //! \return true on success, false on failure. Call error() for more info.
    // -------------------------------------------------------------------------
    inline bool
    extractEntryToMemory(const char* p_entry_name,
                         std::vector<unsigned char>& p_output_buffer)
    {
        return extractEntryToMemory(std::string(p_entry_name), p_output_buffer);
    }

    // -------------------------------------------------------------------------
    //! \brief Closes the archive. Called by the destructor.
    // -------------------------------------------------------------------------
    void close();

    // -------------------------------------------------------------------------
    //! \brief Check if the unzipper is valid.
    //! \return true if the unzipper is valid, false otherwise.
    // -------------------------------------------------------------------------
    bool checkValid();

    // -------------------------------------------------------------------------
    //! \brief Get the error information when a method returned false.
    //! \return Reference to the error code.
    // -------------------------------------------------------------------------
    inline std::error_code const& error() const
    {
        return m_error_code;
    }

private:

    struct Impl;

    //! \brief Whether the archive is open.
    bool m_open = false;
    //! \brief Error code.
    std::error_code m_error_code;
    //! \brief Implementation.
    std::unique_ptr<Impl> m_impl;
};

// *************************************************************************
//! \brief Class representing an entry in a zip archive.
// *************************************************************************
class ZipEntry
{
public:

    //! \brief Default constructor.
    ZipEntry() = default;

    //! \brief Constructor with entry details.
    //!
    //! \param[in] name_ Name of the entry in the zip archive.
    //! \param[in] compressed_size Size of the compressed data in bytes.
    //! \param[in] uncompressed_size Original size of the data in bytes.
    //! \param[in] year Year component of the timestamp.
    //! \param[in] month Month component of the timestamp (1-12).
    //! \param[in] day Day component of the timestamp (1-31).
    //! \param[in] hour Hour component of the timestamp (0-23).
    //! \param[in] minute Minute component of the timestamp (0-59).
    //! \param[in] second Second component of the timestamp (0-59).
    //! \param[in] dosdate_ DOS-format date.
    ZipEntry(std::string const& name_,
             uint64_t compressed_size,
             uint64_t uncompressed_size,
             uint32_t year,
             uint32_t month,
             uint32_t day,
             uint32_t hour,
             uint32_t minute,
             uint32_t second,
             uint32_t dosdate_)
        : name(name_),
          compressedSize(compressed_size),
          uncompressedSize(uncompressed_size),
          dosdate(dosdate_)
    {
        // timestamp YYYY-MM-DD HH:MM:SS
        std::stringstream str;
        str << year << "-" << month << "-" << day << " " << hour << ":"
            << minute << ":" << second;
        timestamp = str.str();

        unixdate.tm_year = year;
        unixdate.tm_mon = month;
        unixdate.tm_mday = day;
        unixdate.tm_hour = hour;
        unixdate.tm_min = minute;
        unixdate.tm_sec = second;
    }

    //! \brief Copy constructor.
    ZipEntry(ZipEntry const& other) = default;

    //! \brief Copy assignment operator.
    ZipEntry& operator=(ZipEntry const& other) = default;

    //! \brief Move assignment operator.
    ZipEntry& operator=(ZipEntry&& other) = default;

    //! \brief Checks if the entry has a valid name.
    //! \return true if the entry name is not empty.
    inline bool valid() const
    {
        return !name.empty();
    }

public:

    //! \brief Structure representing a date and time.
    struct tm_s
    {
        uint32_t tm_sec;  //!< Seconds (0-59)
        uint32_t tm_min;  //!< Minutes (0-59)
        uint32_t tm_hour; //!< Hours (0-23)
        uint32_t tm_mday; //!< Day of month (1-31)
        uint32_t tm_mon;  //!< Month (1-12)
        uint32_t tm_year; //!< Year (full year, e.g. 2022)
    };

    std::string name;      //!< Name of the entry in the zip archive
    std::string timestamp; //!< Formatted timestamp string (YYYY-MM-DD HH:MM:SS)
    uint64_t compressedSize;   //!< Size of the compressed data in bytes
    uint64_t uncompressedSize; //!< Original size of the data in bytes
    uint32_t dosdate;          //!< DOS-format date
    tm_s unixdate;             //!< UNIX-format date and time
};

} // namespace zipper

#endif // ZIPPER_UNZIPPER_HPP
