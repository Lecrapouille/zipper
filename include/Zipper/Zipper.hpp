//-----------------------------------------------------------------------------
// Copyright (c) 2022 Quentin Quadrat <lecrapouille@gmail.com>
// https://github.com/Lecrapouille/zipper distributed under MIT License.
// Based on https://github.com/sebastiandev/zipper/tree/v2.x.y distributed under
// MIT License. Copyright (c) 2015 -- 2022 Sebastian <devsebas@gmail.com>
//-----------------------------------------------------------------------------

#ifndef ZIPPER_ZIPPER_HPP
#define ZIPPER_ZIPPER_HPP

#include <cstdint>
#include <ctime>
#include <iostream>
#include <sstream>
#include <string>
#include <system_error>
#include <vector>

// *****************************************************************************
// Generated by CMake. Needed for exporting symbols for making the libzipper.dll
// on Windows.
// *****************************************************************************
#if defined(ZIPPER_EXPORT_DEFINED)
#    include "zipper_export.h"
#else
#    define ZIPPER_EXPORT
#endif

namespace zipper {

// *************************************************************************
//! \brief Zip archive compressor.
// *************************************************************************
class ZIPPER_EXPORT Zipper
{
public:

    // -------------------------------------------------------------------------
    //! \brief Archive opening flags.
    // -------------------------------------------------------------------------
    enum OpenFlags
    {
        //! \brief Overwrite existing zip file
        Overwrite,
        //! \brief Append to existing zip file
        Append
    };

    // -------------------------------------------------------------------------
    //! \brief Compression options for files.
    // -------------------------------------------------------------------------
    enum ZipFlags
    {
        //! \brief Minizip option: -0 Store only (no compression).
        Store = 0x00,
        //! \brief Minizip option: -1 Compress faster (less compression).
        Faster = 0x01,
        //! \brief Minizip option: -5 Medium compression.
        Medium = 0x05,
        //! \brief Minizip option: -9 Better compression (slower).
        Better = 0x09,
        //! \brief Preserve directory hierarchy when adding files.
        SaveHierarchy = 0x40
    };

    // -------------------------------------------------------------------------
    //! \brief Regular zip compression (inside a disk zip archive file) with a
    //! password.
    //!
    //! \param[in] p_zip_name Path where to create the zip file.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \param[in] p_flags Overwrite (default) or append to existing
    //! zip file.
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(const std::string& p_zip_name,
           const std::string& p_password,
           Zipper::OpenFlags p_flags = Zipper::OpenFlags::Overwrite);

    // -------------------------------------------------------------------------
    //! \brief Regular zip compression (inside a disk zip archive file) without
    //! password.
    //!
    //! \param[in] p_zipname Path where to create the zip file.
    //! \param[in] p_flags Overwrite (default) or append to existing zip file.
    //! \throw std::runtime_error if an error occurs during initialization.
    // -------------------------------------------------------------------------
    Zipper(const std::string& p_zipname,
           Zipper::OpenFlags p_flags = Zipper::OpenFlags::Overwrite)
        : Zipper(p_zipname, std::string(), p_flags)
    {
    }

    // -------------------------------------------------------------------------
    //! \brief In-memory zip compression (storage inside std::iostream).
    //!
    //! \param[in,out] p_buffer Stream in which to store zipped files.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(std::iostream& p_buffer,
           const std::string& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief In-memory zip compression (storage inside std::vector).
    //!
    //! \param[in,out] p_buffer Vector in which to store zipped files.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(std::vector<unsigned char>& p_buffer,
           const std::string& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Calls close() method.
    // -------------------------------------------------------------------------
    ~Zipper();

    // -------------------------------------------------------------------------
    //! \brief Compress data from source with a given timestamp in the archive
    //! with the given name.
    //!
    //! \param[in,out] p_source Data stream to compress.
    //! \param[in] p_timestamp Desired timestamp for the file.
    //! \param[in] p_nameInZip Desired name for the file inside the archive.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure.
    //! \throw std::runtime_error if an error occurs during compression.
    // -------------------------------------------------------------------------
    bool add(std::istream& p_source,
             const std::tm& p_timestamp,
             const std::string& p_nameInZip,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better);

    // -------------------------------------------------------------------------
    //! \brief Compress data from source in the archive with the given name.
    //! No timestamp will be stored.
    //!
    //! \param[in,out] p_source Data stream to compress.
    //! \param[in] p_nameInZip Desired name for the file inside the archive.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure.
    //! \throw std::runtime_error if an error occurs during compression.
    // -------------------------------------------------------------------------
    bool add(std::istream& p_source,
             const std::string& p_nameInZip,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better);

    // -------------------------------------------------------------------------
    //! \brief Compress data from source in the archive with an empty name.
    //!
    //! \param[in,out] p_source Data stream to compress.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure.
    //! \throw std::runtime_error if an error occurs during compression.
    // -------------------------------------------------------------------------
    bool add(std::istream& p_source,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better)
    {
        return add(p_source, std::string(), p_flags);
    }

    // -------------------------------------------------------------------------
    //! \brief Compress a folder or a file in the archive.
    //!
    //! \param[in] p_file_or_folder_path Path to the file or folder to compress.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure.
    //! \throw std::runtime_error if an error occurs during compression.
    // -------------------------------------------------------------------------
    bool add(const std::string& p_file_or_folder_path,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better);

    // -------------------------------------------------------------------------
    //! \brief Compress a folder or a file in the archive.
    //!
    //! \param[in] p_file_or_folder_path Path to the file or folder to compress.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure.
    //! \throw std::runtime_error if an error occurs during compression.
    // -------------------------------------------------------------------------
    bool add(const char* p_file_or_folder_path,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better)
    {
        return add(std::string(p_file_or_folder_path), p_flags);
    }

    // -------------------------------------------------------------------------
    //! \brief Closes the zip archive.
    //!
    //! Depending on the constructor used, this method will close the access to
    //! the zip file, flush the stream, or release memory.
    //! \note This method is called by the destructor.
    // -------------------------------------------------------------------------
    void close();

    // -------------------------------------------------------------------------
    //! \brief Opens or reopens the zip archive.
    //!
    //! To be called after a close(). Depending on the constructor used, this
    //! method will open the zip file or reserve buffers.
    //! \param[in] p_flags Overwrite or append (default) to existing zip file.
    //! \return true on success, false on failure.
    //! \note This method is not called by the constructor.
    // -------------------------------------------------------------------------
    bool open(Zipper::OpenFlags p_flags = Zipper::OpenFlags::Append);

    // -------------------------------------------------------------------------
    //! \brief Check if the zipper is currently open.
    //! \return True if the zipper is open, false otherwise.
    // -------------------------------------------------------------------------
    bool isOpen() const;

    // -------------------------------------------------------------------------
    //! \brief Get the error information when a method returned false.
    //! \return Reference to the error code.
    // -------------------------------------------------------------------------
    std::error_code const& error() const;

private:

    //! \brief Releases allocated resources.
    void release();

private:

    struct Impl;

    //! \brief Stream in which to store zipped files.
    std::iostream& m_output_stream;
    //! \brief Vector in which to store zipped files.
    std::vector<unsigned char>& m_output_vector;
    //! \brief Name of the zip file.
    std::string m_zip_name;
    //! \brief Password for the zip file.
    std::string m_password;
    //! \brief Whether to use a memory vector.
    bool m_using_vector;
    //! \brief Whether to use a stream.
    bool m_using_stream;
    //! \brief Whether the zip file is open.
    bool m_open = false;
    //! \brief Error code.
    std::error_code m_error_code;
    //! \brief Implementation.
    Impl* m_impl;
};

// -------------------------------------------------------------------------
//! \name Bitwise operators for Zipper::ZipFlags
// -------------------------------------------------------------------------

//! \brief Bitwise OR operator for Zipper::ZipFlags.
//! \param[in] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Result of the bitwise OR operation.
inline constexpr Zipper::ZipFlags operator|(Zipper::ZipFlags lhs,
                                            Zipper::ZipFlags rhs)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(static_cast<T>(lhs) |
                                         static_cast<T>(rhs));
}

//! \brief Bitwise AND operator for Zipper::ZipFlags.
//! \param[in] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Result of the bitwise AND operation.
inline constexpr Zipper::ZipFlags operator&(Zipper::ZipFlags lhs,
                                            Zipper::ZipFlags rhs)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(static_cast<T>(lhs) &
                                         static_cast<T>(rhs));
}

//! \brief Bitwise XOR operator for Zipper::ZipFlags.
//! \param[in] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Result of the bitwise XOR operation.
inline constexpr Zipper::ZipFlags operator^(Zipper::ZipFlags lhs,
                                            Zipper::ZipFlags rhs)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(static_cast<T>(lhs) ^
                                         static_cast<T>(rhs));
}

//! \brief Bitwise NOT operator for Zipper::ZipFlags.
//! \param[in] flag Operand.
//! \return Result of the bitwise NOT operation.
inline constexpr Zipper::ZipFlags operator~(Zipper::ZipFlags flag)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(~static_cast<T>(flag));
}

//! \brief Bitwise OR assignment operator for Zipper::ZipFlags.
//! \param[in,out] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Reference to the modified left-hand side operand.
inline Zipper::ZipFlags& operator|=(Zipper::ZipFlags& lhs, Zipper::ZipFlags rhs)
{
    lhs = lhs | rhs;
    return lhs;
}

//! \brief Bitwise AND assignment operator for Zipper::ZipFlags.
//! \param[in,out] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Reference to the modified left-hand side operand.
inline Zipper::ZipFlags& operator&=(Zipper::ZipFlags& lhs, Zipper::ZipFlags rhs)
{
    lhs = lhs & rhs;
    return lhs;
}

//! \brief Bitwise XOR assignment operator for Zipper::ZipFlags.
//! \param[in,out] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Reference to the modified left-hand side operand.
inline Zipper::ZipFlags& operator^=(Zipper::ZipFlags& lhs, Zipper::ZipFlags rhs)
{
    lhs = lhs ^ rhs;
    return lhs;
}

} // namespace zipper

#endif // ZIPPER_ZIPPER_HPP
