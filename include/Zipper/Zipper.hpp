//-----------------------------------------------------------------------------
// Copyright (c) 2022 Quentin Quadrat <lecrapouille@gmail.com>
// https://github.com/Lecrapouille/zipper distributed under MIT License.
// Based on https://github.com/sebastiandev/zipper/tree/v2.x.y distributed under
// MIT License. Copyright (c) 2015 -- 2022 Sebastian <devsebas@gmail.com>
//-----------------------------------------------------------------------------

#ifndef ZIPPER_ZIPPER_HPP
#define ZIPPER_ZIPPER_HPP

#include <cstdint>
#include <ctime>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <system_error>
#include <vector>

// *****************************************************************************
// Generated by CMake. Needed for exporting symbols for making the libzipper.dll
// on Windows.
// *****************************************************************************
#if defined(ZIPPER_EXPORT_DEFINED)
#    include "zipper_export.h"
#else
#    define ZIPPER_EXPORT
#endif

namespace zipper
{

// *************************************************************************
//! \brief Zip archive compressor.
// *************************************************************************
class ZIPPER_EXPORT Zipper
{
    // Forward declaration
    struct Impl;

public:

    // -------------------------------------------------------------------------
    //! \brief Archive opening flags.
    // -------------------------------------------------------------------------
    enum OpenFlags
    {
        //! \brief Overwrite existing zip file
        Overwrite,
        //! \brief Append to existing zip file
        Append
    };

    // -------------------------------------------------------------------------
    //! \brief Compression options for files.
    // -------------------------------------------------------------------------
    enum ZipFlags
    {
        //! \brief Minizip option: -0 Store only (no compression).
        Store = 0x00,
        //! \brief Minizip option: -1 Compress faster (less compression).
        Faster = 0x01,
        //! \brief Minizip option: -5 Medium compression.
        Medium = 0x05,
        //! \brief Minizip option: -9 Better compression (slower).
        Better = 0x09,
        //! \brief Preserve directory hierarchy when adding files.
        SaveHierarchy = 0x40
    };

    // -------------------------------------------------------------------------
    //! \brief Structure holding progress information during compression
    // -------------------------------------------------------------------------
    struct Progress
    {
        //! \brief Status of the compression operation
        enum class Status
        {
            OK,        //!< Compression completed successfully
            KO,        //!< Compression failed
            InProgress //!< Compression in progress
        };

        Status status = Status::InProgress; //!< Current status
        std::string current_file; //!< Name of the current file being compressed
        uint64_t bytes_processed = 0;  //!< Number of bytes processed so far
        uint64_t total_bytes = 0;      //!< Total number of bytes to compress
        uint64_t files_compressed = 0; //!< Number of files compressed
        uint64_t total_files = 0;      //!< Total number of files to compress
    };

    //! \brief Callback type for reporting compression progress
    using ProgressCallback = std::function<void(const Progress&)>;

    // -------------------------------------------------------------------------
    //! \brief Default constructor. You shall use open() method to initialize
    //! the zipper.
    // -------------------------------------------------------------------------
    Zipper();

    // -------------------------------------------------------------------------
    //! \brief Regular zip compression (inside a disk zip archive file) with a
    //! password.
    //!
    //! \param[in] p_zip_name Path where to create the zip file.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \param[in] p_open_flags Overwrite (default) or append to existing
    //! zip file.
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(const std::string& p_zip_name,
           const std::string& p_password,
           Zipper::OpenFlags p_open_flags = Zipper::OpenFlags::Overwrite);

    // -------------------------------------------------------------------------
    //! \brief Regular zip compression (inside a disk zip archive file) without
    //! password.
    //!
    //! \param[in] p_zipname Path where to create the zip file.
    //! \param[in] p_open_flags Overwrite (default) or append to existing zip
    //! file. \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(const std::string& p_zipname,
           Zipper::OpenFlags p_open_flags = Zipper::OpenFlags::Overwrite)
        : Zipper(p_zipname, std::string(), p_open_flags)
    {
    }

    // -------------------------------------------------------------------------
    //! \brief In-memory zip compression (storage inside std::iostream).
    //!
    //! \param[in,out] p_buffer Stream in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_open_flags Optional flags to control how the zip is opened.
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(std::iostream& p_buffer, Zipper::OpenFlags p_open_flags)
        : Zipper(p_buffer, std::string(), p_open_flags)
    {
    }

    // -------------------------------------------------------------------------
    //! \brief In-memory zip compression (storage inside std::iostream).
    //!
    //! \param[in,out] p_buffer Stream in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \param[in] p_open_flags Optional flags to control how the zip is opened.
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(std::iostream& p_buffer,
           const std::string& p_password,
           Zipper::OpenFlags p_open_flags);

    // -------------------------------------------------------------------------
    //! \brief In-memory zip compression (storage inside std::iostream).
    //!
    //! \param[in,out] p_buffer Stream in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(std::iostream& p_buffer, const std::string& p_password);

    // -------------------------------------------------------------------------
    //! \brief In-memory zip compression (storage inside std::vector).
    //!
    //! \param[in,out] p_buffer Vector in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \throw std::runtime_error if an error occurs during
    //! initialization.
    // -------------------------------------------------------------------------
    Zipper(std::vector<unsigned char>& p_buffer,
           const std::string& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Destructor automatically calls close().
    // -------------------------------------------------------------------------
    ~Zipper();

    // Disable copy and move semantics
    Zipper(const Zipper&) = delete;
    Zipper& operator=(const Zipper&) = delete;
    Zipper(Zipper&&) = delete;
    Zipper& operator=(Zipper&&) = delete;

    // -------------------------------------------------------------------------
    //! \brief Compress data from source with a given timestamp in the archive
    //! with the given name.
    //!
    //! \param[in,out] p_source Data stream to compress.
    //! \param[in] p_timestamp Desired timestamp for the file.
    //! \param[in] p_name_in_zip Desired name for the file inside the archive.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool add(std::istream& p_source,
             const std::tm& p_timestamp,
             const std::string& p_name_in_zip,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better);

    // -------------------------------------------------------------------------
    //! \brief Compress data from source in the archive with the given name.
    //! Uses current time as timestamp.
    //!
    //! \param[in,out] p_source Data stream to compress.
    //! \param[in] p_name_in_zip Desired name for the file inside the archive.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool add(std::istream& p_source,
             const std::string& p_name_in_zip,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better);

    // -------------------------------------------------------------------------
    //! \brief Compress data from source in the archive with an empty name.
    //! Uses current time as timestamp.
    //!
    //! \param[in,out] p_source Data stream to compress.
    //! \param[in] p_flags Compression options (faster, better, etc.).
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool add(std::istream& p_source,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better)
    {
        return add(p_source, std::string(), p_flags);
    }

    // -------------------------------------------------------------------------
    //! \brief Compress a folder or a file in the archive.
    //!
    //! \param[in] p_file_or_folder_path Path to the file or folder to compress.
    //! \param[in] p_flags Compression options (faster, better, etc.). If
    //! Zipper::ZipFlags::SaveHierarchy is included, the directory structure
    //! relative to the input path is preserved.
    //! \return true on success (all files added), false on failure (at least
    //! one file failed). Sets internal error code on failure.
    // -------------------------------------------------------------------------
    bool add(const std::string& p_file_or_folder_path,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better);

    // -------------------------------------------------------------------------
    //! \brief Compress a folder or a file in the archive.
    //!
    //! \param[in] p_file_or_folder_path Path to the file or folder to compress.
    //! \param[in] p_flags Compression options (faster, better, etc.). If
    //! Zipper::ZipFlags::SaveHierarchy is included, the directory structure
    //! relative to the input path is preserved.
    //! \return true on success (all files added), false on failure (at least
    //! one file failed). Sets internal error code on failure.
    // -------------------------------------------------------------------------
    bool add(const char* p_file_or_folder_path,
             Zipper::ZipFlags p_flags = Zipper::ZipFlags::Better)
    {
        return add(std::string(p_file_or_folder_path), p_flags);
    }

    // -------------------------------------------------------------------------
    //! \brief Closes the zip archive.
    //!
    //! Depending on the constructor used, this method will close the access to
    //! the zip file, flush the stream, or update the memory vector.
    //! \note This method is automatically called by the destructor. It's safe
    //! to call multiple times.
    // -------------------------------------------------------------------------
    void close();

    // -------------------------------------------------------------------------
    //! \brief Opens or reopens the zip archive.
    //!
    //! If the archive was previously closed, this re-initializes it for
    //! appending or overwriting based on the mode it was originally created
    //! with (file, stream, or vector) and the provided flags.
    //! \param[in] p_flags Overwrite or append (default) to existing zip file.
    //! Only relevant for file-based zippers.
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    //! \note This method is not called by the constructor. If called on an
    //! already open zipper, it first closes it.
    // -------------------------------------------------------------------------
    bool open(const std::string& p_zip_name,
              const std::string& p_password,
              Zipper::OpenFlags p_open_flags = Zipper::OpenFlags::Overwrite);

    // -------------------------------------------------------------------------
    //! \brief Open the zip archive from a file.
    //!
    //! \param[in] p_zipname Path to the zip file.
    //! \param[in] p_open_flags Overwrite (default) or append to existing zip
    //! file.
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool open(const std::string& p_zipname,
              Zipper::OpenFlags p_open_flags = Zipper::OpenFlags::Overwrite);

    // -------------------------------------------------------------------------
    //! \brief Open the zip archive from a stream.
    //!
    //! \param[in,out] p_buffer Stream in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \param[in] p_open_flags Overwrite (default) or append to existing zip
    //! file.
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool open(std::iostream& p_buffer,
              const std::string& p_password,
              Zipper::OpenFlags p_open_flags);

    // -------------------------------------------------------------------------
    //! \brief Open the zip archive from a stream.
    //!
    //! \param[in,out] p_buffer Stream in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool open(std::iostream& p_buffer,
              const std::string& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Open the zip archive from a vector.
    //!
    //! \param[in,out] p_buffer Vector in which to store zipped files. Must
    //! remain valid for the lifetime of the Zipper object.
    //! \param[in] p_password Optional password (empty for no password
    //! protection).
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool open(std::vector<unsigned char>& p_buffer,
              const std::string& p_password = std::string());

    // -------------------------------------------------------------------------
    //! \brief Close and reopen the zipper.
    //! \return true on success, false on failure. Sets internal error code on
    //! failure.
    // -------------------------------------------------------------------------
    bool reopen();

    // -------------------------------------------------------------------------
    //! \brief Check if the zipper is currently open and ready for adding files.
    //! \return True if the zipper is open, false otherwise.
    // -------------------------------------------------------------------------
    inline bool isOpened() const
    {
        return m_open;
    }

    // -------------------------------------------------------------------------
    //! \brief Get the error information when a method returned false.
    //! \return Reference to the error code. The error code is cleared on the
    //! next successful operation or successful open().
    // -------------------------------------------------------------------------
    inline std::error_code const& error() const
    {
        return m_error_code;
    }

    // -------------------------------------------------------------------------
    //! \brief Set the progress callback function.
    //! \param[in] callback The function to call with progress updates.
    //! \return true if the callback was set successfully.
    // -------------------------------------------------------------------------
    bool setProgressCallback(ProgressCallback callback);

private:

    // -------------------------------------------------------------------------
    //! \brief Check if the zipper is valid.
    //! \return true if the zipper is valid, false otherwise.
    // -------------------------------------------------------------------------
    bool checkValid();

private:

    //! \brief Stream to store zipped files, if using stream constructor.
    //! Null otherwise.
    std::iostream* m_output_stream = nullptr;
    //! \brief Vector to store zipped files, if using vector constructor.
    //! Null otherwise.
    std::vector<unsigned char>* m_output_vector = nullptr;
    //! \brief Name of the zip file, if using file constructor.
    std::string m_zip_name;
    //! \brief Password for the zip file.
    std::string m_password;
    //! \brief Overwrite or append (default) to existing zip file.
    OpenFlags m_open_flags = OpenFlags::Overwrite;
    //! \brief Whether the zip archive is currently open.
    bool m_open = false;
    //! \brief Stores the last error.
    std::error_code m_error_code;
    //! \brief PIMPL implementation detail.
    std::unique_ptr<Impl> m_impl;
};

// -------------------------------------------------------------------------
//! \name Bitwise operators for Zipper::ZipFlags
// -------------------------------------------------------------------------

//! \brief Bitwise OR operator for Zipper::ZipFlags.
//! \param[in] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Result of the bitwise OR operation.
inline constexpr Zipper::ZipFlags operator|(Zipper::ZipFlags lhs,
                                            Zipper::ZipFlags rhs)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(static_cast<T>(lhs) |
                                         static_cast<T>(rhs));
}

//! \brief Bitwise AND operator for Zipper::ZipFlags.
//! \param[in] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Result of the bitwise AND operation.
inline constexpr Zipper::ZipFlags operator&(Zipper::ZipFlags lhs,
                                            Zipper::ZipFlags rhs)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(static_cast<T>(lhs) &
                                         static_cast<T>(rhs));
}

//! \brief Bitwise XOR operator for Zipper::ZipFlags.
//! \param[in] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Result of the bitwise XOR operation.
inline constexpr Zipper::ZipFlags operator^(Zipper::ZipFlags lhs,
                                            Zipper::ZipFlags rhs)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(static_cast<T>(lhs) ^
                                         static_cast<T>(rhs));
}

//! \brief Bitwise NOT operator for Zipper::ZipFlags.
//! \param[in] flag Operand.
//! \return Result of the bitwise NOT operation.
inline constexpr Zipper::ZipFlags operator~(Zipper::ZipFlags flag)
{
    using T = std::underlying_type_t<Zipper::ZipFlags>;
    return static_cast<Zipper::ZipFlags>(~static_cast<T>(flag));
}

//! \brief Bitwise OR assignment operator for Zipper::ZipFlags.
//! \param[in,out] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Reference to the modified left-hand side operand.
inline Zipper::ZipFlags& operator|=(Zipper::ZipFlags& lhs, Zipper::ZipFlags rhs)
{
    lhs = lhs | rhs;
    return lhs;
}

//! \brief Bitwise AND assignment operator for Zipper::ZipFlags.
//! \param[in,out] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Reference to the modified left-hand side operand.
inline Zipper::ZipFlags& operator&=(Zipper::ZipFlags& lhs, Zipper::ZipFlags rhs)
{
    lhs = lhs & rhs;
    return lhs;
}

//! \brief Bitwise XOR assignment operator for Zipper::ZipFlags.
//! \param[in,out] lhs Left-hand side operand.
//! \param[in] rhs Right-hand side operand.
//! \return Reference to the modified left-hand side operand.
inline Zipper::ZipFlags& operator^=(Zipper::ZipFlags& lhs, Zipper::ZipFlags rhs)
{
    lhs = lhs ^ rhs;
    return lhs;
}

} // namespace zipper

#endif // ZIPPER_ZIPPER_HPP
