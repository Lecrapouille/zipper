//-----------------------------------------------------------------------------
// Copyright (c) 2022 Quentin Quadrat <lecrapouille@gmail.com>
// https://github.com/Lecrapouille/zipper distributed under MIT License.
// Based on https://github.com/sebastiandev/zipper/tree/v2.x.y distributed under
// MIT License. Copyright (c) 2015 -- 2022 Sebastian <devsebas@gmail.com>
//
// Copyright (C) 2008 by Pedro Mendes, Virginia Tech Intellectual
// Properties, Inc., EML Research, gGmbH, University of Heidelberg,
// and The University of Manchester.
// All rights reserved.
//
// Copyright (C) 2001 - 2007 by Pedro Mendes, Virginia Tech Intellectual
// Properties, Inc. and EML Research, gGmbH.
// All rights reserved.
//-----------------------------------------------------------------------------

#ifndef ZIPPER_UTILS_PATH_HPP
#  define ZIPPER_UTILS_PATH_HPP

#  include <string>
#  include <vector>

// *****************************************************************************
// Generated by CMake. Needed for exporting symbols for unit tests with Windows
// if compiled as shared library.
// FIXME: Ideally this class should not be exported since it is not part of the
// public API. https://github.com/Lecrapouille/zipper/issues/21
// *****************************************************************************
#if defined(ZIPPER_EXPORT_DEFINED)
#  include "zipper_export.h"
#else
#  define ZIPPER_EXPORT
#endif
namespace zipper {

// *****************************************************************************
//! \brief This class provides an OS independent interface to directory entries
//! such as files and directories.
// *****************************************************************************
class ZIPPER_EXPORT Path
{
public:
    //! \brief Returns the preferred separator for the current OS
    //! \param[in] path Path to get the preferred separator from
    //! \return char Preferred separator
    static char preferredSeparator(const std::string& path);

    //! \brief Convert any path separators to the native format for the current OS
    //! \param[in] path Path with potentially mixed separators
    //! \return std::string Path with consistent OS-specific separators
    static std::string toNativeSeparators(const std::string& path);

    //! \brief Convert all path separators to Unix format (forward slash)
    //! \param[in] path Path to convert
    //! \return std::string Path with Unix separators
    static std::string toUnixSeparators(const std::string& path);

    //! \brief Convert all path separators to Windows format (backslash)
    //! \param[in] path Path to convert
    //! \return std::string Path with Windows separators
    static std::string toWindowsSeparators(const std::string& path);

    //! \brief Standardize path separators for storage in ZIP archives
    //! This method converts all separators to the format most commonly used in ZIP archives (forward slash)
    //! \param[in] path Path to standardize
    //! \return std::string Path with standardized separators for ZIP storage
    static std::string toZipArchiveSeparators(const std::string& path);

    //! \brief Detect if a path contains mixed separators
    //! \param[in] path Path to check
    //! \return bool True if path contains both Windows and Unix separators
    static bool hasMixedSeparators(const std::string& path);

    //! \brief Returns the root of the path.
    //! \param[in] path Path to get the root of
    //! \return std::string Root of the path
    static std::string root(const std::string& path);

    //! \brief Checks if the path is a pure root.
    //! \param[in] path Path to check
    //! \return bool True if path is a pure root
    static bool isRoot(const std::string& path);

    //! \brief Returns the current path.
    //! \return std::string Current path
    static std::string currentPath();

    //! \brief Check whether the directory entry specified by 'path' is
    //! a file.
    //! \param[in] path: file path.
    //! \return bool isFile
    static bool isFile(const std::string& path);

    //! \brief Check whether the directory entry specified by 'path' is
    //! is a directory.
    //! \param[in] path: file path.
    //! \return bool isDir
    static bool isDir(const std::string& path);

    //! \brief Returns the directory name with the preferred separator
    //! \param[in] folder_path: folder path
    //! \return std::string directory name with preferred separator
    static std::string folderNameWithSeparator(const std::string& folder_path);

    //! \brief Check whether the directory entry specified by 'path' exists.
    //! \param[in] path: file path.
    //! \return bool exist
    static bool exist(const std::string& path);

    //! \brief Check whether the directory entry specified by 'path' is
    //! is readable.
    //! \param[in] path: file path.
    //! \return bool isReadable
    static bool isReadable(const std::string& path);

    //! \brief Check whether the directory entry specified by 'path' is
    //! writable.
    //! \param[in] path: file path.
    //! \return bool isWritable
    static bool isWritable(const std::string& path);

    //! \brief Returns the base name, i.e., the directory path and the
    //! the suffix are removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string baseName
    // static std::string baseName(const std::string& path);

    //! \brief Returns the file name, i.e., the directory path is removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string fileName
    static std::string fileName(const std::string& path);

    //! \brief Returns the directory path to the parent directoryu, i.e.,
    //! the file name or directory name are removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string dirName
    static std::string dirName(const std::string& path);

    //! \brief Returns the extension, i.e., the directory path and the
    //! the base name are removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string extension
    static std::string extension(const std::string& path);

    //! \brief Create the directory 'dir' in the parent directory 'parent'.
    //! \param[in] dir: folder path.
    //! \param[in] parent (Default: current working directory)
    //! \return bool success
    static bool createDir(const std::string& dir,
                          const std::string& parent = "");

    static void removeDir(const std::string& foldername);

    //! \brief Return the list of the folder. If recurse == false then stay
    //! inside the first depth.
    static std::vector<std::string> filesFromDir(const std::string& path,
                                                 const bool recurse);

    //! \brief Return the temporary directory for the current OS
    //! \return std::string Temporary directory
    static std::string getTempDirectory();

    //! \brief Create a name for a temporary directory entry. The directory entry
    //! will be located in the directory given
    //! \param[in] dir: folder path.
    //! \param[in] suffix: file extension.
    //! \return std::string tmpName
    static std::string createTempName(const std::string& dir,
                                      const std::string& suffix);

    //! \brief Move a file from. If to is the directory the filename of from is
    //! appended.
    //! \param[in] from: source path.
    //! \param[in] to:  destination path.
    //! \return bool success
    static bool move(const std::string& from,
                     const std::string& to);

    //! \brief Removes a file or directory specified by path.
    //! \param[in] path: file path.
    //! \return bool success

    static bool remove(const std::string& path);

    //! \brief Remove files or directories matching the pattern in directory dir.
    //! \param[in] pattern
    //! \param[in] dir
    //! \return bool success
    static bool removeFiles(const std::string& pattern,
                            const std::string& dir);

    //! \brief Compiles the pattern to a patternList. Valid wildcards in the pattern are:
    //! '*' matches any number of characters and '?' matches exactly one character.
    //! \param[in] pattern
    //! \return std::vector< std::string > patternList

    static std::vector<std::string> compilePattern(const std::string& pattern);

    //! \brief Compare the name against the pattern list and returns whether the
    //! name matches. The patternList can be created from a pattern by the
    //! compilePattern method.
    //! \param[in] name
    //! \param[in] patternList
    //! \return bool match
    static bool match(const std::string& name,
                      const std::vector<std::string>& patternList);

    //! \brief Checks whether the given path is relative
    //! \param[in] path: file path.
    //! \return bool isRelative

    static bool isRelativePath(const std::string& path);

#if 0
    //! \brief Makes the absolute path relative to the path given in relativeTo
    //! \param[in] absolutePath
    //! \param[in] relativeTo
    //! \return bool success
    static bool makePathRelative(std::string& absolutePath,
                                 const std::string& relativeTo);

    //! \brief Makes the relative path absolute to the path given in absoluteTo
    //! \param[in] relativePath
    //! \param[in] absoluteTo
    //! \return bool success
    static bool makePathAbsolute(std::string& relativePath,
                                 const std::string& absoluteTo);
#endif

    //! \brief This method normalizes the path, i.e.,
    //! it converts all '\' to '/' (only on WIN32)
    //! and collapses '^./' to '^', '/./' to '/', and '[^/]+/../' to '/'
    //! \param[in] path
    //! \return std::string normalizedPath
    static std::string normalize(const std::string& path);

    //! \brief This substitute ../ ie foo/../bar will return bar
    static std::string canonicalPath(const std::string& path);

    static bool isLargeFile(std::istream& input_stream);

    //! \biref Check if the file name ends with a backslash or slash char
    static bool hasTrailingSlash(const std::string& path);

private:

    //! \brief This private methods checks whether the active section matches the
    //! specified patter. The section is automatically advanced to allow
    //! repeated calls. On the first call 'at' must be 0. The parameters
    //! 'at' and 'after' must not be changed outside this method.
    //! \param[in] name
    //! \param[in] pattern
    //! \param[out] at
    //! \param[out] after
    //! \return bool match
    static bool matchInternal(const std::string& name,
                              const std::string pattern,
                              std::string::size_type& at,
                              std::string::size_type& after);
};

} // namespace

#endif // ZIPPER_UTILS_PATH_HPP
