//-----------------------------------------------------------------------------
// Copyright (c) 2022 Quentin Quadrat <lecrapouille@gmail.com>
// https://github.com/Lecrapouille/zipper distributed under MIT License.
// Based on https://github.com/sebastiandev/zipper/tree/v2.x.y distributed under
// MIT License. Copyright (c) 2015 -- 2022 Sebastian <devsebas@gmail.com>
//
// Copyright (C) 2008 by Pedro Mendes, Virginia Tech Intellectual
// Properties, Inc., EML Research, gGmbH, University of Heidelberg,
// and The University of Manchester.
// All rights reserved.
//
// Copyright (C) 2001 - 2007 by Pedro Mendes, Virginia Tech Intellectual
// Properties, Inc. and EML Research, gGmbH.
// All rights reserved.
//-----------------------------------------------------------------------------

#ifndef ZIPPER_UTILS_PATH_HPP
#define ZIPPER_UTILS_PATH_HPP

#include <string>
#include <vector>

// *****************************************************************************
// Generated by CMake. Needed for exporting symbols for unit tests with Windows
// if compiled as shared library.
// FIXME: Ideally this class should not be exported since it is not part of the
// public API. https://github.com/Lecrapouille/zipper/issues/21
// *****************************************************************************
#if defined(ZIPPER_EXPORT_DEFINED)
#    include "zipper_export.h"
#else
#    define ZIPPER_EXPORT
#endif
namespace zipper {

// *****************************************************************************
//! \brief This class provides an OS independent interface to directory entries
//! such as files and directories.
// *****************************************************************************
class ZIPPER_EXPORT Path
{
public:

    //! \brief Returns the preferred separator for the current OS
    //! \param[in] path Path to get the preferred separator from
    //! \return char Preferred separator
    static char preferredSeparator(const std::string& path);

    //! \brief Convert any path separators to the native format for the current
    //! OS \param[in] path Path with potentially mixed separators \return
    //! std::string Path with consistent OS-specific separators
    static std::string toNativeSeparators(const std::string& path);

    //! \brief Convert all path separators to Unix format (forward slash)
    //! \param[in] path Path to convert
    //! \return std::string Path with Unix separators
    static std::string toUnixSeparators(const std::string& path);

    //! \brief Convert all path separators to Windows format (backslash)
    //! \param[in] path Path to convert
    //! \return std::string Path with Windows separators
    static std::string toWindowsSeparators(const std::string& path);

    //! \brief Standardize path separators for storage in ZIP archives
    //! This method converts all separators to the format most commonly used in
    //! ZIP archives (forward slash) \param[in] path Path to standardize \return
    //! std::string Path with standardized separators for ZIP storage
    static std::string toZipArchiveSeparators(const std::string& path);

    //! \brief Detect if a path contains mixed separators
    //! \param[in] path Path to check
    //! \return bool True if path contains both Windows and Unix separators
    static bool hasMixedSeparators(const std::string& path);

    //! \brief Returns the root of the path.
    //! \param[in] path Path to get the root of
    //! \return std::string Root of the path
    static std::string root(const std::string& path);

    //! \brief Check if the path is a root.
    //! \param[in] path Path to check
    //! \return bool True if path is a root
    static bool isRoot(const std::string& path);

    //! \brief Returns the current working directory path.
    //! \details This function returns the current working directory path with
    //! the following features:
    //! - Uses dynamic buffer allocation to handle long paths
    //! - Normalizes path separators to the native format
    //! - Handles errors gracefully
    //! - Supports paths up to 32KB in length
    //! \return std::string Current working directory path, or empty string on
    //! error
    static std::string currentPath();

    //! \brief Check whether the directory entry specified by 'path' is
    //! a file.
    //! \param[in] path: file path.
    //! \return bool isFile
    static bool isFile(const std::string& path);

    //! \brief Check whether the directory entry specified by 'path' is
    //! is a directory.
    //! \param[in] path: file path.
    //! \return bool isDir
    static bool isDir(const std::string& path);

    //! \brief Returns the directory name with the preferred separator
    //! \param[in] folder_path: folder path
    //! \return std::string directory name with preferred separator
    static std::string folderNameWithSeparator(const std::string& folder_path);

    //! \brief Check whether the directory entry specified by 'path' exists.
    //! \param[in] path: file path.
    //! \return bool exist
    static bool exist(const std::string& path);

    //! \brief Check whether the directory entry specified by 'path' is
    //! is readable.
    //! \param[in] path: file path.
    //! \return bool isReadable
    static bool isReadable(const std::string& path);

    //! \brief Check whether the directory entry specified by 'path' is
    //! writable.
    //! \param[in] path: file path.
    //! \return bool isWritable
    static bool isWritable(const std::string& path);

    //! \brief Returns the base name, i.e., the directory path and the
    //! the suffix are removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string baseName
    // static std::string baseName(const std::string& path);

    //! \brief Returns the file name, i.e., the directory path is removed from
    //! 'path'. \param[in] path: file path. \return std::string fileName
    static std::string fileName(const std::string& path);

    //! \brief Returns the directory path to the parent directoryu, i.e.,
    //! the file name or directory name are removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string dirName
    static std::string dirName(const std::string& path);

    //! \brief Returns the extension, i.e., the directory path and the
    //! the base name are removed from 'path'.
    //! \param[in] path: file path.
    //! \return std::string extension
    static std::string extension(const std::string& path);

    //! \brief Create the directory 'dir' in the parent directory 'parent'.
    //! \param[in] dir: folder path.
    //! \param[in] parent (Default: current working directory)
    //! \return bool success
    static bool createDir(const std::string& dir,
                          const std::string& parent = "");

    static void removeDir(const std::string& foldername);

    //! \brief Return the list of the folder. If recurse == false then stay
    //! inside the first depth.
    static std::vector<std::string> filesFromDir(const std::string& path,
                                                 const bool recurse);

    //! \brief Return the temporary directory for the current OS
    //! \return std::string Temporary directory
    static std::string getTempDirectory();

    //! \brief Create a name for a temporary directory entry. The directory
    //! entry will be located in the directory given \param[in] dir: folder
    //! path. \param[in] suffix: file extension. \return std::string tmpName
    static std::string createTempName(const std::string& dir,
                                      const std::string& suffix);

    //! \brief Removes a file or directory specified by path.
    //! \param[in] path: file path.
    //! \return bool success

    static bool remove(const std::string& path);

    //! \brief Checks whether the given path is relative
    //! \param[in] path: file path.
    //! \return bool isRelative
    static bool isRelativePath(const std::string& path);

    //! \brief This substitute ../ ie foo/../bar will return bar
    static std::string normalize(const std::string& path);

    //! \brief Returns the canonical path of the destination directory.
    //! \param[in] p_destination_dir The destination directory path
    //! \return std::string Canonical path of the destination directory
    static std::string canonicalPath(const std::string& p_destination_dir);

    static bool isLargeFile(std::istream& input_stream);

    //! \biref Check if the file name ends with a backslash or slash char
    static bool hasTrailingSlash(const std::string& path);

    //! \brief Get the size of a file in bytes.
    //! \param[in] path Path to the file.
    //! \return size_t File size in bytes, or 0 if the file does not exist or is
    //! not a file.
    static size_t getFileSize(const std::string& path);

    //! \brief Checks if a ZIP entry could be used for a zip slip attack
    //! \param[in] p_entry_path The path inside the ZIP file
    //! \param[in] p_target_dir The destination directory path
    //! \return true if the entry could escape the destination directory
    static bool isZipSlip(const std::string& p_entry_path,
                          const std::string& p_target_dir);

    enum class InvalidEntryReason
    {
        VALID_ENTRY = 0,
        EMPTY_ENTRY = 1,
        FORBIDDEN_CHARACTERS = 2,
        CONTROL_CHARACTERS = 3,
        ABSOLUTE_PATH = 4,
        ZIP_SLIP = 5
    };

    //! \brief Checks if a ZIP entry name is valid
    //! \param[in] p_entry_name The entry name to check
    //! \return true if the entry name is valid
    static InvalidEntryReason isValidEntry(const std::string& p_entry_name);

    //! \brief Returns a string describing the reason why a ZIP entry name is
    //! invalid
    //! \param[in] p_reason The reason why the entry name is invalid
    //! \return std::string Description of the reason
    static std::string getInvalidEntryReason(InvalidEntryReason p_reason);
};

} // namespace zipper

#endif // ZIPPER_UTILS_PATH_HPP